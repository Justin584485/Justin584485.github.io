<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/30/Label%20constrain%20shortest%20distance/"/>
    <url>/2024/03/30/Label%20constrain%20shortest%20distance/</url>
    
    <content type="html"><![CDATA[<h1 id="label-constrain-shortest-distance-论文阅读笔记">Label constrainshortest distance 论文阅读笔记</h1><h2 id="naive-approach">Naive approach</h2><h3 id="index-structure">Index structure:</h3><ul><li><p>Index's entry: 不同的label set</p></li><li><p>e.g.</p><figure><imgsrc="C:\Users\11970\AppData\Roaming\Typora\typora-user-images\image-20240330213237960.png"alt="image-20240330213237960" /><figcaption aria-hidden="true">image-20240330213237960</figcaption></figure></li></ul><p>每个结点<span class="math inline">\(X(v)\)</span> 都记录着顶点<spanclass="math inline">\(v\)</span>到达其余顶点在当前labelset构成的子图上，到其余顶点<spanclass="math inline">\(u\)</span>的距离。</p><h3 id="query-process">Query process</h3><ul><li>给定顶点<span class="math inline">\(s,t\)</span>，首先计算出它们在树分解得到的树上的最小公共祖先<spanclass="math inline">\(X_{lca}\)</span>.之后，再进行迭代，分别计算出<spanclass="math inline">\(s\)</span>和<spanclass="math inline">\(t\)</span>到<spanclass="math inline">\(X_{lca}\)</span>当中的结点的最小距离（因为它们构成了一个V_cut）。之后向上更新，沿途每一层，都更新该层结点到<spanclass="math inline">\(s\)</span>的最短路径<spanclass="math inline">\(d_s(u) =min\{d_s(u),d_s(v)+dis(v,u)\}\)</span></li><li>也就是说<spanclass="math inline">\(s\)</span>对于祖先结点当中的任意一顶点，想要到达，路径上的顶点都已经存在于它们两个之间。</li><li>对于<span class="math inline">\(t\)</span>也是一样的计算方式</li><li>如何理解LEMMA 4.1？相当于是把c的周围邻居都砍掉了。这两个不相交的部分，相当于是一个2-HOP，所以中间相交的部分就是必经之路。</li></ul><figure><imgsrc="C:\Users\11970\Documents\WeChat%20Files\wxid_fpiwmfmlp6l922\FileStorage\Temp\1be5fc7b1dee3d488ccf4f1a295362c.jpg"alt="1be5fc7b1dee3d488ccf4f1a295362c" /><figcaptionaria-hidden="true">1be5fc7b1dee3d488ccf4f1a295362c</figcaption></figure><ul><li>question： 如何确保<span class="math inline">\(s\)</span>到<spanclass="math inline">\(X_{lca}\)</span>最短路径计算的准确性？貌似与treedecomposition的形成有关</li></ul><h3 id="construct-index">Construct index</h3><ul><li>tree decomposition (MDE), 然后每次计算出来一个node<spanclass="math inline">\(X(v)\)</span>都用Dijkstra算法，计算出来<spanclass="math inline">\(v\)</span>到别的顶点的距离。（在新构建出来的子图上）</li></ul><h2 id="new-index-approach">NEW INDEX APPROACH</h2><p>上述算法的效率高，但是带来了太多的index。</p><figure><imgsrc="C:\Users\11970\AppData\Roaming\Typora\typora-user-images\image-20240331203728067.png"alt="image-20240331203728067" /><figcaption aria-hidden="true">image-20240331203728067</figcaption></figure><p>观察上述图-<span class="math inline">\(v_1\)</span>到<spanclass="math inline">\(v_6\)</span>, 对于<spanclass="math inline">\(\{b,r\}\)</span>和<spanclass="math inline">\(\{g,r\}\)</span>以及<spanclass="math inline">\(\{r\}\)</span>，它们走的最短路径都是<spanclass="math inline">\(\{r\}\)</span>里面所走的路线。因此，可以设计出一个新的index，可以不储存冗余的信息。</p><p>那么如何定义一个非冗余的最短路径：</p><ul><li>设<span class="math inline">\(p\)</span>为<spanclass="math inline">\(u,v\)</span>之间的最短路径，如果另外一条路径的labelset包含了<span class="math inline">\(p\)</span>的labelset，那么它的长度也会比<spanclass="math inline">\(p\)</span>的路径更长。</li></ul><p>有了如下定义：</p><ul><li><p>Label-constrained Shortest Distance Set</p><p>对于任意两点，Set标记为<spanclass="math inline">\(S(u,v)=\{(L_1,d_1), (L_2,d_2),...\}\)</span></p><p>有如下性质：</p><ol type="1"><li>对于每个<span class="math inline">\((L_i,d_i)\)</span>,都存在一条路径<span class="math inline">\(p\)</span>​,使得路径和d都相等</li><li>对于存在的每条path，都有一个term对应：L1 包含于p，d&lt;=p。这一条保证了，所有的path都能被label set给覆盖到</li><li>对于每条path、每个term，如果path的label比term小，那么path的距离就会比d更大。这条保证了冗余性，不会出现如果一条path不在S上，然后它的labelset比所有的label更小，d也更小。</li></ol></li></ul><h3 id="index-structure-1">Index Structure</h3><p>直接对原图做tree decomposition。在每个<spanclass="math inline">\(X(v)\)</span>当中，提前计算好<spanclass="math inline">\(v\)</span>到其余顶点<spanclass="math inline">\(u\)</span>​的距离。</p><figure><imgsrc="C:\Users\11970\AppData\Roaming\Typora\typora-user-images\image-20240331211328827.png"alt="image-20240331211328827" /><figcaption aria-hidden="true">image-20240331211328827</figcaption></figure><h3 id="query-process-1">Query Process</h3><ol type="1"><li>找到<span class="math inline">\(s,t\)</span>​的lowest commanancestor</li><li>跟刚才的查询步骤一样，迭代向上查询，分别计算<spanclass="math inline">\(s\)</span>和<spanclass="math inline">\(t\)</span>到<spanclass="math inline">\(X_{lca}\)</span>​的距离，区别是中间计算的时候，只选label存在于给定的labelset当中的距离。</li></ol><p>通过上述方法的构建，index的数量被减少到了<spanclass="math inline">\(O(n \cdot w \cdot \rho)\)</span> 。</p><h3 id="index-construction">Index Construction</h3><p>整体的思想就是，在treedecomposition的过程当中构造LSDS，通过已有的LSDS构造未完成的LSDS。</p><p>给出了两种方法： 给定两个distance set，<spanclass="math inline">\(S^{&#39;}_{p}\)</span>和<spanclass="math inline">\(S^{&#39;&#39;}_{p}\)</span>，（它们是有着不同的u,v的），<spanclass="math inline">\(LSDSJoin(S^{&#39;}_{p},S^{&#39;&#39;}_{p})=\{任意两个labelset合并，并且两个distance相加\}\)</span></p><p><spanclass="math inline">\(LSDSPrune(S^{&#39;}_{p},S^{&#39;&#39;}_{p})=\{消除掉冗余的term\}\)</span>​</p><ul><li><p>Algorithm: 整个构建过程分为两步：</p><ol type="1"><li><p>做tree decomposition，获得partial LSDS</p><p>初始化原图作为G，将树初始化为empty。对于<spanclass="math inline">\(G\)</span>当中的每条边，初始化<spanclass="math inline">\(S_p(u,v)={(l((u,v)),\phi((u,v)))}\)</span>，之后，每一步都做顶点消除。在第<spanclass="math inline">\(i\)</span>代elimination,都从<spanclass="math inline">\(G_{i-1}\)</span>当中消去一个顶点，并且记录下它的消去order为i。在消去的时候，对它们的邻居做join操作。如果<spanclass="math inline">\(u\)</span>和<spanclass="math inline">\(w\)</span>之间没有边，就把<spanclass="math inline">\(S(v,w)\)</span>作为最后的结果。如果有有边，那么就把<spanclass="math inline">\(S(u,w)\)</span>与结果的并集作为结果返回。创建<spanclass="math inline">\(X(v)\)</span>。在所有消去步骤完成之后，分配<spanclass="math inline">\(X(v)\)</span>当中具有最小的<spanclass="math inline">\(\pi(\cdot)\)</span>​的node作为其父结点。至此，index初步完成。</p><ul><li>假设<span class="math inline">\(u\)</span>的order小于<spanclass="math inline">\(v\)</span></li><li></li></ul></li><li><p>根据partial LSDS来构建complete LSDS</p><ul><li>LSD Preserved Graph: 对于phase 1当中每一步产生的<spanclass="math inline">\(G_i\)</span>，都有一个LSD Preserved Graph <spanclass="math inline">\(G&#39;\)</span>,如果它们在原来的图中有一条边，那么在<spanclass="math inline">\(G&#39;\)</span>当中，对于<spanclass="math inline">\(S(u,v)\)</span>当中的每一项，<spanclass="math inline">\(G&#39;\)</span>​都有一条边与其对应。</li><li>在<span class="math inline">\(G&#39;\)</span>当中，从<spanclass="math inline">\(v\)</span>到<spanclass="math inline">\(u\)</span>的最短路径要么就是直接相连，要么就是只经过<spanclass="math inline">\(X(v)\)</span>当中除了<spanclass="math inline">\(v和u\)</span>的另外一个顶点。</li></ul></li></ol></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
