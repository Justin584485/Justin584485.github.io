<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/06/15/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/15/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="day1">Day1</h1><h2 id="跳跃游戏ⅱ">#45 跳跃游戏Ⅱ</h2><figure><imgsrc="C:\Users\11970\AppData\Roaming\Typora\typora-user-images\image-20240615121505882.png"alt="image-20240615121505882" /><figcaption aria-hidden="true">image-20240615121505882</figcaption></figure><p>题解：维护一个<code>max_pos</code>,再维护一个<code>end</code>，当<code>i</code>位于<code>end</code>之间的时候，就更新<code>maxPos</code>,当走到<code>end</code>的时候，更新<code>maxPos</code>.</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxPos = <span class="hljs-number">0</span>, step = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt; n<span class="hljs-number">-1</span>; i++)&#123;<br>            <br>                maxPos = <span class="hljs-built_in">max</span>(maxPos, i+nums[i]);<br>                <span class="hljs-keyword">if</span>( i == end)&#123;<br>                    end = maxPos;<br>                    step++;<br>                &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> step;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="无重复字符的最长子串">#3 无重复字符的最长子串</h2><figure><imgsrc="C:\Users\11970\AppData\Roaming\Typora\typora-user-images\image-20240616020518046.png"alt="image-20240616020518046" /><figcaption aria-hidden="true">image-20240616020518046</figcaption></figure><p>思路：滑动窗口，注意<code>right</code>和<code>left</code>值的计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        unordered_set &lt;<span class="hljs-type">char</span>&gt; hash;<br>        <span class="hljs-type">int</span> maxLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tempLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(s[i]) == hash.<span class="hljs-built_in">end</span>())&#123;<br>                hash.<span class="hljs-built_in">insert</span>(s[i]);<br>                right = i;<br>                tempLength = right - left + <span class="hljs-number">1</span>;<br>                maxLength = <span class="hljs-built_in">max</span>(maxLength, tempLength);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right = i;<br>                <span class="hljs-keyword">while</span>(left &lt; right&amp;&amp;hash.<span class="hljs-built_in">find</span>(s[right]) != hash.<span class="hljs-built_in">end</span>())&#123;<br>                    hash.<span class="hljs-built_in">erase</span>(s[left]);<br>                    left++;<br>                &#125;<br>                hash.<span class="hljs-built_in">insert</span>(s[i]);<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/06/15/C++%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%20d1/"/>
    <url>/2024/06/15/C++%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%20d1/</url>
    
    <content type="html"><![CDATA[<h1 id="c学习日记-d1">C++学习日记 d1</h1><h2 id="main">Main()</h2><ol type="1"><li><strong>返回值：</strong>main函数被启动代码调用，启动代码是由编译器加到程序当中的，作为程序和操作系统的接口。main自动返回一个整数值，再ANSI/ISOC++里面默认返回0</li><li>main()是不可缺少的，但是存在特殊情况：在windows编程当中，可以编写一个动态链接库（DLL）模块，用于别的程序，不是独立的程序，可以没有main</li></ol><h2 id="cout">cout</h2><ul><li><p>使用cout输出整数的时候，会先将这个整数转化为字符串</p></li><li><p>与printf相比的优势：</p><ol type="1"><li><p><code>printf()</code>需要显示说明输出变量的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is a num: %s/n&quot;</span>, num);<br></code></pre></td></tr></table></figure></li><li><p>如果指定的类型和变量本身的类型相左，会出现乱码</p></li></ol></li></ul><h2 id="类的简介">类的简介</h2><ul><li>cout就是一个<code>ostream</code>类的对象</li></ul><h2 id="函数的简介">函数的简介</h2><ul><li>函数是不可以嵌套定义的</li></ul><h2 id="整型">整型</h2><p>分别为<code>char</code>,<code>short</code>,<code>int</code>,<code>long</code>,<code>long long</code>(为c++11新增)</p><ul><li><p>short最少16位</p></li><li><p>int至少和short一样长</p></li><li><p>long至少32位，且至少和int一样长</p></li><li><p>long long至少是64位，且至少和long一样长</p></li><li><p>计算机内存的基本单位是bit(位)</p></li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0d1/"/>
    <url>/2024/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0d1/</url>
    
    <content type="html"><![CDATA[<h1 id="day-1-最大堆和快排">day 1 最大堆和快排</h1><h2 id="最大堆">最大堆</h2><ul><li>MAX-HEAPIFY: 时间复杂度为<spanclass="math inline">\(O(lgn)\)</span>,具体实现就是从上往下维护堆的性质，把不符合最大堆的结点往下调整。</li><li>BUILD-MAX-HEAP: 时间复杂度为<spanclass="math inline">\(O(n)\)</span>：在高度为h（其中h为该点到叶结点之间的距离）的结点有<spanclass="math inline">\(n/2^{(h+1)}\)</span>个结点，所以复杂度就是对它们求和，最后得到<spanclass="math inline">\(O(n)\)</span></li><li>HEAPSORT(堆排序)： 最后的复杂度就是<spanclass="math inline">\(O(nlgn)\)</span>​，因为每次将堆头的结点与堆尾的结点进行互换，做MAX-HEAPIFY，执行n次。</li><li>最好，最坏，平均都是<spanclass="math inline">\(O(nlgn)\)</span>，<strong>不稳定</strong></li></ul><h2 id="快速排序">快速排序</h2><p>时间复杂度</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/30/Label%20constrain%20shortest%20distance/"/>
    <url>/2024/03/30/Label%20constrain%20shortest%20distance/</url>
    
    <content type="html"><![CDATA[<h1 id="label-constrain-shortest-distance-论文阅读笔记">Label constrainshortest distance 论文阅读笔记</h1><h2 id="naive-approach">Naive approach</h2><h3 id="index-structure">Index structure:</h3><ul><li><p>Index's entry: 不同的label set</p></li><li><p>e.g.</p><figure><imgsrc="C:\Users\11970\AppData\Roaming\Typora\typora-user-images\image-20240330213237960.png"alt="image-20240330213237960" /><figcaption aria-hidden="true">image-20240330213237960</figcaption></figure></li></ul><p>每个结点<span class="math inline">\(X(v)\)</span> 都记录着顶点<spanclass="math inline">\(v\)</span>到达其余顶点在当前labelset构成的子图上，到其余顶点<spanclass="math inline">\(u\)</span>的距离。</p><h3 id="query-process">Query process</h3><ul><li>给定顶点<span class="math inline">\(s,t\)</span>，首先计算出它们在树分解得到的树上的最小公共祖先<spanclass="math inline">\(X_{lca}\)</span>.之后，再进行迭代，分别计算出<spanclass="math inline">\(s\)</span>和<spanclass="math inline">\(t\)</span>到<spanclass="math inline">\(X_{lca}\)</span>当中的结点的最小距离（因为它们构成了一个V_cut）。之后向上更新，沿途每一层，都更新该层结点到<spanclass="math inline">\(s\)</span>的最短路径<spanclass="math inline">\(d_s(u) =min\{d_s(u),d_s(v)+dis(v,u)\}\)</span></li><li>也就是说<spanclass="math inline">\(s\)</span>对于祖先结点当中的任意一顶点，想要到达，路径上的顶点都已经存在于它们两个之间。</li><li>对于<span class="math inline">\(t\)</span>也是一样的计算方式</li><li>如何理解LEMMA 4.1？相当于是把c的周围邻居都砍掉了。这两个不相交的部分，相当于是一个2-HOP，所以中间相交的部分就是必经之路。</li></ul><figure><imgsrc="C:\Users\11970\Documents\WeChat%20Files\wxid_fpiwmfmlp6l922\FileStorage\Temp\1be5fc7b1dee3d488ccf4f1a295362c.jpg"alt="1be5fc7b1dee3d488ccf4f1a295362c" /><figcaptionaria-hidden="true">1be5fc7b1dee3d488ccf4f1a295362c</figcaption></figure><ul><li>question： 如何确保<span class="math inline">\(s\)</span>到<spanclass="math inline">\(X_{lca}\)</span>最短路径计算的准确性？貌似与treedecomposition的形成有关</li></ul><h3 id="construct-index">Construct index</h3><ul><li>tree decomposition (MDE), 然后每次计算出来一个node<spanclass="math inline">\(X(v)\)</span>都用Dijkstra算法，计算出来<spanclass="math inline">\(v\)</span>到别的顶点的距离。（在新构建出来的子图上）</li></ul><h2 id="new-index-approach">NEW INDEX APPROACH</h2><p>上述算法的效率高，但是带来了太多的index。</p><figure><imgsrc="C:\Users\11970\AppData\Roaming\Typora\typora-user-images\image-20240331203728067.png"alt="image-20240331203728067" /><figcaption aria-hidden="true">image-20240331203728067</figcaption></figure><p>观察上述图-<span class="math inline">\(v_1\)</span>到<spanclass="math inline">\(v_6\)</span>, 对于<spanclass="math inline">\(\{b,r\}\)</span>和<spanclass="math inline">\(\{g,r\}\)</span>以及<spanclass="math inline">\(\{r\}\)</span>，它们走的最短路径都是<spanclass="math inline">\(\{r\}\)</span>里面所走的路线。因此，可以设计出一个新的index，可以不储存冗余的信息。</p><p>那么如何定义一个非冗余的最短路径：</p><ul><li>设<span class="math inline">\(p\)</span>为<spanclass="math inline">\(u,v\)</span>之间的最短路径，如果另外一条路径的labelset包含了<span class="math inline">\(p\)</span>的labelset，那么它的长度也会比<spanclass="math inline">\(p\)</span>的路径更长。</li></ul><p>有了如下定义：</p><ul><li><p>Label-constrained Shortest Distance Set</p><p>对于任意两点，Set标记为<spanclass="math inline">\(S(u,v)=\{(L_1,d_1), (L_2,d_2),...\}\)</span></p><p>有如下性质：</p><ol type="1"><li>对于每个<span class="math inline">\((L_i,d_i)\)</span>,都存在一条路径<span class="math inline">\(p\)</span>​,使得路径和d都相等</li><li>对于存在的每条path，都有一个term对应：L1 包含于p，d&lt;=p。这一条保证了，所有的path都能被label set给覆盖到</li><li>对于每条path、每个term，如果path的label比term小，那么path的距离就会比d更大。这条保证了冗余性，不会出现如果一条path不在S上，然后它的labelset比所有的label更小，d也更小。</li></ol></li></ul><h3 id="index-structure-1">Index Structure</h3><p>直接对原图做tree decomposition。在每个<spanclass="math inline">\(X(v)\)</span>当中，提前计算好<spanclass="math inline">\(v\)</span>到其余顶点<spanclass="math inline">\(u\)</span>​的距离。</p><figure><imgsrc="C:\Users\11970\AppData\Roaming\Typora\typora-user-images\image-20240331211328827.png"alt="image-20240331211328827" /><figcaption aria-hidden="true">image-20240331211328827</figcaption></figure><h3 id="query-process-1">Query Process</h3><ol type="1"><li>找到<span class="math inline">\(s,t\)</span>​的lowest commanancestor</li><li>跟刚才的查询步骤一样，迭代向上查询，分别计算<spanclass="math inline">\(s\)</span>和<spanclass="math inline">\(t\)</span>到<spanclass="math inline">\(X_{lca}\)</span>​的距离，区别是中间计算的时候，只选label存在于给定的labelset当中的距离。</li></ol><p>通过上述方法的构建，index的数量被减少到了<spanclass="math inline">\(O(n \cdot w \cdot \rho)\)</span> 。</p><h3 id="index-construction">Index Construction</h3><p>整体的思想就是，在treedecomposition的过程当中构造LSDS，通过已有的LSDS构造未完成的LSDS。</p><p>给出了两种方法： 给定两个distance set，<spanclass="math inline">\(S^{&#39;}_{p}\)</span>和<spanclass="math inline">\(S^{&#39;&#39;}_{p}\)</span>，（它们是有着不同的u,v的），<spanclass="math inline">\(LSDSJoin(S^{&#39;}_{p},S^{&#39;&#39;}_{p})=\{任意两个labelset合并，并且两个distance相加\}\)</span></p><p><spanclass="math inline">\(LSDSPrune(S^{&#39;}_{p},S^{&#39;&#39;}_{p})=\{消除掉冗余的term\}\)</span>​</p><ul><li><p>Algorithm: 整个构建过程分为两步：</p><ol type="1"><li><p>做tree decomposition，获得partial LSDS</p><p>初始化原图作为G，将树初始化为empty。对于<spanclass="math inline">\(G\)</span>当中的每条边，初始化<spanclass="math inline">\(S_p(u,v)={(l((u,v)),\phi((u,v)))}\)</span>，之后，每一步都做顶点消除。在第<spanclass="math inline">\(i\)</span>代elimination,都从<spanclass="math inline">\(G_{i-1}\)</span>当中消去一个顶点，并且记录下它的消去order为i。在消去的时候，对它们的邻居做join操作。如果<spanclass="math inline">\(u\)</span>和<spanclass="math inline">\(w\)</span>之间没有边，就把<spanclass="math inline">\(S(v,w)\)</span>作为最后的结果。如果有有边，那么就把<spanclass="math inline">\(S(u,w)\)</span>与结果的并集作为结果返回。创建<spanclass="math inline">\(X(v)\)</span>。在所有消去步骤完成之后，分配<spanclass="math inline">\(X(v)\)</span>当中具有最小的<spanclass="math inline">\(\pi(\cdot)\)</span>​的node作为其父结点。至此，index初步完成。</p><ul><li>假设<span class="math inline">\(u\)</span>的order小于<spanclass="math inline">\(v\)</span></li><li></li></ul></li><li><p>根据partial LSDS来构建complete LSDS</p><ul><li>LSD Preserved Graph: 对于phase 1当中每一步产生的<spanclass="math inline">\(G_i\)</span>，都有一个LSD Preserved Graph <spanclass="math inline">\(G&#39;\)</span>,如果它们在原来的图中有一条边，那么在<spanclass="math inline">\(G&#39;\)</span>当中，对于<spanclass="math inline">\(S(u,v)\)</span>当中的每一项，<spanclass="math inline">\(G&#39;\)</span>​都有一条边与其对应。</li><li>在<span class="math inline">\(G&#39;\)</span>当中，从<spanclass="math inline">\(v\)</span>到<spanclass="math inline">\(u\)</span>的最短路径要么就是直接相连，要么就是只经过<spanclass="math inline">\(X(v)\)</span>当中除了<spanclass="math inline">\(v和u\)</span>的另外一个顶点。</li></ul></li></ol></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
